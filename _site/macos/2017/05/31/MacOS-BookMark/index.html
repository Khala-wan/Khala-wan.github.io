<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8">
<meta name="author" content="万圣">
<meta name="description" content="这里放满了胡思乱想">
<title> MacOS-BookMark解决沙盒化文件读取权限问题 › Khala-Wan`</title>
<link rel="canonical" href="http://localhost:4000/macos/2017/05/31/MacOS-BookMark/">
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,300italic,400italic" rel="stylesheet">
<link href="//fonts.googleapis.com/css?family=Gentium+Basic:400,400italic" rel="stylesheet">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/basic.css" rel="stylesheet">
<link href="/highlight.css" rel="stylesheet">
<link href="/index.css" rel="stylesheet">
<link href="/customized.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Khala-Wan`" />


<header>
  <h1><a href="/">Khala-Wan`</a></h1>
  <nav>
    <li><a href="/">Home</a></li><li><a href="/Projects/">Projects</a></li><li><a href="/about/">About me</a></li><li><a href="/archive/">Archive</a></li>
  </nav>
</header>
<main>
  <article class="light">
    <div id="toc"></div>
    	<script src="/toc.js"></script>
		<script type="text/javascript">
			$(document).ready(function() {
    		$('#toc').toc();
		</script>
    <header id="123">
      <h2><a href="/macos/2017/05/31/MacOS-BookMark/">MacOS-BookMark解决沙盒化文件读取权限问题</a></h2>
      <span><time datetime="2017-05-31T20:13:21+08:00">May 31, 2017</time> • MacOS</span>
    </header>
    <div>
<p>BookMarkData是Foundation中一个数据类型。它能帮助我们让沙盒化的MacOS App获取沙盒之外的文件信息。</p>

<h2 id="沙盒机制">沙盒机制</h2>
<p>首先让我们先复习下沙盒机制，OSX从10.6系统开始引入沙盒机制,并且规定发布到Mac AppStore的应用必须遵守沙盒机制。这样能防止恶意的App通过系统漏洞攻击系统获取控制权限,保证了OSX系统的安全。沙盒对应用访问的各个系统资源都做了限制。
大致如下：</p>
<ul>
  <li>用户文件</li>
  <li>硬件外设</li>
  <li>网络</li>
  <li>XPC</li>
  <li>其他</li>
</ul>

<p>正如我们创建了一个新的MacOS App的项目后看到的沙盒配置页面。</p>
<div align="center"><img style="border: 1px solid #dcdcdc" width="500" height="300" src="https://github.com/Khala-wan/Khala-wan.github.io/raw/master/resource/BookMark/0.jpg" /></div>

<h2 id="遇到的问题">遇到的问题</h2>
<p>我在开发自己的MacOS APP的时候发现了这样的问题：我在沙盒中配置了用户选择的文件的读写权限。之后利用NSOpenPanel选中某个文件后读取其中的信息。这在每次选择之后都是可以完成的。但是当我把该文件的URL存入DB后。想让APP下一次启动之后再去读取这个文件时就出现了问题。</p>
<blockquote>
  <p>报错：Operation cannot be completed</p>
</blockquote>

<p>仔细想了一下应该还是权限问题，于是验证：再一次通过NSOpenPanel选择这个文件之后又可以正常读取了。
之后听朋友说这个功能需要用bookmark实现。于是果断尝试bookmark</p>

<h2 id="bookmark">BookMark</h2>
<p>随后发现了这么几个API：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// Returns bookmark data for the URL, created with specified options and resource values.</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">bookmarkData</span><span class="p">(</span><span class="nv">options</span><span class="p">:</span> <span class="kt">URL</span><span class="o">.</span><span class="kt">BookmarkCreationOptions</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="n">includingResourceValuesForKeys</span> <span class="nv">keys</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">URLResourceKey</span><span class="o">&gt;</span><span class="p">?</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="n">relativeTo</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span> <span class="o">=</span> <span class="k">default</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span>
</code></pre>
</div>
<p>这个API用来把你从NSOpenPanel获取到的文件URL（file:///User/XXX）通过指定的bookMark创建选项和URLResourceKey生成BookMarkData。我们需要在DB中存入这个BookMarkData。</p>

<p>这个<strong>BookmarkCreationOptions</strong>是什么呢？它是BookMark创建选项的枚举。有如下选项：</p>

<ul>
  <li>minimalBookmark 
(见名知意，生成一个能被j解析的最小的书签)</li>
  <li>suitableForBookmarkFile
这个枚举用来处理替身文件。关于如何处理替身文件可以看下老谭的这篇文章。<a href="http://www.tanhao.me/pieces/1646.html/">对替身(Alias)文件的操作</a></li>
  <li>withSecurityScope
这个就是我们需要的对用户私密文件进行操作的选项了。</li>
  <li>securityScopeAllowOnlyReadAccess
同上，但是只读你懂得。</li>
</ul>

<p><strong>URLResourceKey</strong>是适用于文件系统的URL key。一般传nil就行。在API定义中已经赋值defualt。如果想了解更详细，请看Apple文档:<a href="https://developer.apple.com/reference/foundation/urlresourcekey">URLResourceKey</a></p>

<p>OK.继续说我们的BookMark。我们通过URL创建了BookMarkData。也存了DB。那么要怎么用呢？来看这个URL的构造方法：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">/// Initializes a URL that refers to a location specified by resolving bookmark data.</span>
<span class="kd">public</span> <span class="nf">init</span><span class="p">?(</span><span class="n">resolvingBookmarkData</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="kt">URL</span><span class="o">.</span><span class="kt">BookmarkResolutionOptions</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="n">relativeTo</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">?</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="nv">bookmarkDataIsStale</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Bool</span><span class="p">)</span> <span class="k">throws</span>
</code></pre>
</div>
<p>通过传入我们之前存DB的BookMarkData和指定的配置。就可以得到我们之前获取到的文件地址。</p>

<p><strong>relativeTo url</strong> 是我们BookMarkData对应的baseURL。可以传nil使用默认值</p>

<p><strong>bookmarkDataIsStale</strong> 标识BookMarkData是否过期，如果过期还需要重新创建。</p>

<p>通过BookMark解析出的fileURL有个很好的好处：当用户修改了这个文件的地址。那么我们再次生成的fileURL也会随之改变。这样帮我们省了很多麻烦。</p>

<h2 id="使用bookmark生成的url访问文件">使用BookMark生成的URL访问文件</h2>
<p>如果你已经尝试了上面的两个API，那么你会发现还是访问不了。因为我们还没用进行最重要的一步：
来着这两个API。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="nf">startAccessingSecurityScopedResource</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">/// Revokes the access granted to the url by a prior successful call to startAccessingSecurityScopedResource.</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">stopAccessingSecurityScopedResource</span><span class="p">()</span>
</code></pre>
</div>
<p>在我们要开始读取文件的时候要先调用startAccessingSecurityScopedResource()方法。让我们进入安全访问范围。然后就可读取文件了：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">exportFileExists</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span><span class="kt">URL</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">Bool</span><span class="p">{</span>
    <span class="k">guard</span> <span class="o">!</span><span class="n">path</span><span class="o">.</span><span class="n">absoluteString</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">".Trash"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="nf">startAccessingSecurityScopedResource</span><span class="p">()</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="nf">contentsOfDirectory</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="nf">deletingLastPathComponent</span><span class="p">(),</span> <span class="nv">includingPropertiesForKeys</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="o">.</span><span class="n">skipsHiddenFiles</span><span class="p">)</span><span class="o">.</span><span class="nf">filter</span><span class="p">({</span> <span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">fileName</span><span class="p">:</span><span class="kt">String</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">lastPathComponent</span>
        <span class="k">return</span> <span class="n">fileName</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"txt"</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="n">path</span><span class="o">.</span><span class="nf">stopAccessingSecurityScopedResource</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">{</span>
        <span class="n">path</span><span class="o">.</span><span class="nf">stopAccessingSecurityScopedResource</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<blockquote>
  <p>⚠️⚠️⚠️注意：</p>
</blockquote>

<blockquote>
  <p>1.使用startAccessingSecurityScopedResource()时必须要和stopAccessingSecurityScopedResource()配套使用进行平衡。如果不这样的话会造成泄漏。后果你不想看到的。</p>
</blockquote>

<blockquote>
  <p>2.虽然这两个方法看上去像retain和release。但是它们并不是操作了引用计数哟。</p>
</blockquote>

<h2 id="最后">最后</h2>
<p>BookMark和URL配合能解决我们在开发沙盒化APP时很多关于资源操作的问题。我在这里抛砖引玉，希望大家多多探索bookMark，并写点东西一起学习~</p>

    </div>
    
    <!--  -->
    
    <div id="container"></div>
		<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
		<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
		<script>
			var gitment = new Gitment({
  				id: 'MacOS-BookMark解决沙盒化文件读取权限问题', // 可选。默认为 location.href
  				owner: 'Khala-wan',
  				repo: 'Gitment',
  				oauth: {
    				client_id: '4a573894138f17234910',
    				client_secret: '55d6763ae533805391c04757ba8d925c04f4639d',
  				},
			})
			gitment.render('container');
		</script>
	
	</article>
</main>
<footer>
  <span><a href="http://localhost:4000">万圣</a></span>
  <span><a href="https://github.com/Khala-wan"><i class="fa fa-github-square"></i></a><a href="http://steamcommunity.com/profiles/76561198086573396/"><i class="fa fa-steam-square"></i></a><a href="http://weibo.com/u/2506284730/home?wvr=5"><i class="fa fa-weibo"></i></a><a href="https://github.com/Khala-wan/Khala-wan.github.io/raw/master/resource/social/weixinQR.jpeg"><i class="fa fa-weixin"></i></a></span>
  <span>© 2017</span>
</footer>
